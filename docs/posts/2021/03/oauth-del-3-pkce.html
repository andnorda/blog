<!doctype html>
<html lang="">

<head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.87.0" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="OAuth del 3 (PKCE) - nais blog">
    <meta name="twitter:description" content="Bakgrunn Dette er del 3 i serien om OAuth og OIDC. Den mest brukte OAuth-flyten, &amp;ldquo;Authorization Code flow&amp;rdquo;, innebærer at client og id provider utveksler hemmeligheter. Klienten må derfor være i stand til å holde på hemmelig informasjon på en trygg måte, i standarden omtales dette som confidential clients. For mobil-apps og &amp;ldquo;single page&amp;rdquo; webapplikasjoner har dette ikke vært gjennomførbart da hemmelighetene må distribueres helt ut til sluttbrukeren som en del av appen.">
    <meta name="twitter:site" content="https://nais.io/blog">
    <meta name="twitter:creator" content="Jan-Kåre Solbakken">
    <meta name="twitter:image" content="https://nais.io/blog/images/nais-logo.png">

    
    <meta property="og:locale" content="">
    <meta property="og:type" content="article">
    <meta property="og:title" content="OAuth del 3 (PKCE) - nais blog">
    <meta property="og:description" content="Bakgrunn Dette er del 3 i serien om OAuth og OIDC. Den mest brukte OAuth-flyten, &amp;ldquo;Authorization Code flow&amp;rdquo;, innebærer at client og id provider utveksler hemmeligheter. Klienten må derfor være i stand til å holde på hemmelig informasjon på en trygg måte, i standarden omtales dette som confidential clients. For mobil-apps og &amp;ldquo;single page&amp;rdquo; webapplikasjoner har dette ikke vært gjennomførbart da hemmelighetene må distribueres helt ut til sluttbrukeren som en del av appen.">
    <meta property="og:url" content="https://nais.io/blog/posts/2021/03/oauth-del-3-pkce.html">
    <meta property="og:site_name" content="nais blog">
    <meta property="og:image" content="https://nais.io/blog/images/nais-logo.png">

    <title>OAuth del 3 (PKCE) - nais blog</title>

    <meta name="author" content="NAIS-team">
    <meta name="description" content="Bakgrunn Dette er del 3 i serien om OAuth og OIDC. Den mest brukte OAuth-flyten, &amp;ldquo;Authorization Code flow&amp;rdquo;, innebærer at client og id provider utveksler hemmeligheter. Klienten må derfor være i stand til å holde på hemmelig informasjon på en trygg måte, i standarden omtales dette som confidential clients. For mobil-apps og &amp;ldquo;single page&amp;rdquo; webapplikasjoner har dette ikke vært gjennomførbart da hemmelighetene må distribueres helt ut til sluttbrukeren som en del av appen.">

    
    

    
    

    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
    <link rel="stylesheet" href="https://nais.io/blog/css/theme.css">
    <link rel="stylesheet" href="https://nais.io/blog/css/chroma.dracula.css">

   
   <script async src="https://www.googletagmanager.com/gtag/js?id=G-2TMPV1DG35"></script>
   <script>
   window.dataLayer = window.dataLayer || [];
   function gtag(){dataLayer.push(arguments);}
   gtag('js', new Date());
   gtag('config', 'G-2TMPV1DG35', {
         'anonymize_ip': true,
         'allow_google_signals': false,
         'allow_ad_personalization_signals': false
   });
   </script>
</head>
<body class="font-serif bg-gray-200 border-t-4 border-blue-500 antialiased">
    <div class="w-full p-6 md:w-2/3 md:px-0 md:mx-auto xl:w-2/5">
        <header class="mb-6">
            
            <div class="mb-6 md:flex md:items-center">
                
<div>
    <a class="text-lg mb-8 inline-block" href="/blog">&larr; Back Home</a>

    
    
    <h1 class="text-4xl font-bold">OAuth del 3 (PKCE)</h1>
    OAuth Proof Key for Code Exchange (PKCE)
    <br />
    <br />
    <time datetime="2021-03-07 12:49:37 &#43;0100">07 Mar 2021</time>
    (Jan-Kåre Solbakken)
    
    
    
    <ol class="mt-4">
        
        <li class="inline-block">
            <a class="border-none text-gray-800 text-xs bg-gray-400 hover:bg-gray-600 hover:text-white rounded-sm px-3 py-1" href="https://nais.io/blog/tags/oauth">oauth</a>
        </li>
        
        <li class="inline-block">
            <a class="border-none text-gray-800 text-xs bg-gray-400 hover:bg-gray-600 hover:text-white rounded-sm px-3 py-1" href="https://nais.io/blog/tags/oidc">oidc</a>
        </li>
        
        <li class="inline-block">
            <a class="border-none text-gray-800 text-xs bg-gray-400 hover:bg-gray-600 hover:text-white rounded-sm px-3 py-1" href="https://nais.io/blog/tags/sikkerhet">sikkerhet</a>
        </li>
        
    </ol>
    
</div>

            </div>

            
            
        </header>

        
        
<article class="mb-12">
    <p><img src="/blog/images/oauth2.png" alt="OAuth2"></p>
<h2 id="bakgrunn">Bakgrunn</h2>
<p>Dette er del 3 i serien om OAuth og OIDC. Den mest brukte OAuth-flyten, &ldquo;Authorization Code flow&rdquo;, innebærer at <code>client</code> og <code>id provider</code> utveksler hemmeligheter. Klienten må derfor være i stand til å holde på hemmelig informasjon på en trygg måte, i standarden omtales dette som <code>confidential clients</code>. For mobil-apps og &ldquo;single page&rdquo; webapplikasjoner har dette ikke vært gjennomførbart da hemmelighetene må distribueres helt ut til sluttbrukeren som en del av appen.</p>
<p>I <a href="/blog/posts/2020/09/oauth-del-1.html">del 1</a> ble standarden og terminologien gjennomgått, ta en titt på den hvis du trenger en innføring eller oppfriskning.</p>
<p>Authorization Code flow har også en svakhet som kalles &ldquo;authorization code injection&rdquo;. Et slikt angrep er komplisert å gjennomføre og krever at mange ting skal klaffe samtidig, men er ingen umulighet. Dersom noen som har stjålet din <code>client_id</code> og <code>client_secret</code> klarer å fange opp en authorization code kan de gjøre et token-kall på dine vegne, og dermed utgi seg for den aktuelle sluttbrukeren. Hvordan klarer man så å fange opp en authorization code? Callbacks gjøres jo kun til (forhåpentligvis) forhåndsgodkjente URLer over HTTPS? Vel, ikke alltid. En måte er å utnytte custom &ldquo;URL schemes&rdquo; på telefoner. En telefon-app vil typisk registrere callback URLs av type <code>myapp://something</code>, dette gjør at kallene rutes til denne appen. Hvis en angriper får deg til å installere en app som registrerer seg som lytter på myapp-URLs vil denne appen også få tilsendt callbackene som inneholder koden.</p>
<h2 id="pkce">PKCE</h2>
<p>For å bøte på disse svakhetene har det blitt laget et tillegg til OAuth-standarden. Tillegget beskriver teknikken &ldquo;Proof Key for Code Exchange&rdquo; som forkortes &ldquo;PKCE&rdquo; og uttales &ldquo;pixie&rdquo;.</p>
<p>Authorization Code flow ser ut som vist i figuren (se <a href="/blog/posts/2020/09/oauth-del-1.html">del 1</a> for detaljer).</p>
<p><img src="/blog/images/auth_code.png" alt="authorization code flow"></p>
<p>PKCE legger på følgende tillegg:</p>
<ul>
<li>Klienten genererer en tilfeldig verdi som kalles <code>code_verifier</code>. Denne brukes til å generere en <code>code_challenge</code> vha en forhåndsavtalt metode. Challengen og <code>code_challenge_method</code> legges som ekstra parametre på det initielle <code>/auth</code>-kallet til id-provideren.</li>
<li>Id-provider svarer som vanlig, men tar vare på <code>code_challenge</code> og <code>code_challenge_method</code>.</li>
<li>Klienten sender <code>authorization_code</code> som vanlig med i <code>/token</code>-kallet, men legger i tillegg på den samme <code>code_verifier</code> som ble generert i punkt 1.</li>
<li>Id-provider bruker <code>code_verifier</code> til å generere en <code>code_challenge</code> på samme måte som klienten gjorde. Hvis de to code challengene ikke er like avvises forespørselen.</li>
</ul>
<p>Et auth-kall vi da kunne se ut som følger:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">GET /auth?
     <span class="nv">response_type</span><span class="o">=</span>code<span class="p">&amp;</span>
     <span class="nv">client_id</span><span class="o">=</span>myclient<span class="p">&amp;</span>
     <span class="nv">redirect_url</span><span class="o">=</span>myapp://callback<span class="p">&amp;</span>
     <span class="nv">scope</span><span class="o">=</span>whatever<span class="p">&amp;</span>
     <span class="nv">state</span><span class="o">=</span>123<span class="p">&amp;</span>
     <span class="nv">code_challenge</span><span class="o">=</span>elUXu5zy4QT2f92GRaUq23autAeNDf4DQPaycR0ek_o
</code></pre></div><p>Angripere som kjenner din <code>client_id</code> og <code>client_secret</code> vil dermed ikke kunne gjøre token-kall fordi de ikke kjenner verifieren som ble generert og brukt i punkt 1. Selv om de er i stand til å observere både requesten til og responsen fra <code>/auth</code>-endepunktet vil de ikke være i stand til å rekonstruere code challengen.</p>
<p>Standarden definerer to ulike metoder å lage code challenges med: <code>plain</code> og <code>S256</code>. Plain vil si at code_verifier og code_challenge er samme verdi. For S256 lages code_challenge etter følgende oppskrift:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">base64UrlEncode</span><span class="p">(</span><span class="nx">sha256</span><span class="p">(</span><span class="nx">ascii</span><span class="p">(</span><span class="nx">code_verifier</span><span class="p">)))</span>
</code></pre></div><p>Plain challenges har jo begrenset nytteverdi, så klientene er pålagt å bruke S256 med mindre særlige begrensninger i ressurser eller annet gjør at de ikke er i stand til det. Siden sikkerheten er basert på at code verifieren ikke kan brute forces er det viktig at den er tilfeldig nok (standarden foreslår en entropi på minimum 256 bit). For å holde implementasjonen enkel (og fordi entropien er sterk i utgangspunktet) kreves det ikke salting.</p>
<p>PKCE er støttet i flere biblioteker for flere språk, deriblant <a href="https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/examples/oauth/pkce">Java/Kotlin</a>, <a href="https://github.com/ory/fosite">Go</a> og <a href="https://github.com/panva/node-openid-client">JavaScript</a>.</p>
<h2 id="videre-lesningfordypning">Videre lesning/fordypning</h2>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7636">RFC 7636</a> (Proof Key for Code Exchange by OAuth Public Clients)</li>
<li>OAuth-delen av <a href="https://portswigger.net/web-security/oauth">PortSwigger Web Security Academy</a></li>
<li><a href="https://www.youtube.com/watch?v=1ot45WwQWJE">Eksempel</a> på code injection-angrep</li>
</ul>

</article>


        <footer>
            <p>
                &copy; 2021. nais.io
            </p>
        </footer>
    </div>

    
</body>
</html>
